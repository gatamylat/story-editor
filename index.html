<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <meta name="apple-mobile-web-app-title" content="Story Editor">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#667eea">
  
  <title>Story Editor Pro</title>
  
  <!-- PWA Manifest -->
  <link rel="manifest" href="manifest.json">
  
  <!-- iOS иконки -->
  <link rel="apple-touch-icon" href="icons/icon-192.png">
  <link rel="apple-touch-icon" sizes="152x152" href="icons/icon-152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="icons/icon-180.png">
  <link rel="apple-touch-icon" sizes="167x167" href="icons/icon-167.png">
  
  <!-- Favicon -->
  <link rel="icon" type="image/png" sizes="32x32" href="icons/icon-32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="icons/icon-16.png">
  
  <!-- Splash screens для iOS -->
  <link rel="apple-touch-startup-image" href="icons/splash-2048x2732.png" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2)">
  <link rel="apple-touch-startup-image" href="icons/splash-1668x2388.png" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2)">
  <link rel="apple-touch-startup-image" href="icons/splash-1536x2048.png" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2)">
  <link rel="apple-touch-startup-image" href="icons/splash-1125x2436.png" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3)">
  
  <style>
    /* Встроенные шрифты через base64 для офлайн работы */
    @font-face {
      font-family: 'Inter';
      font-style: normal;
      font-weight: 400;
      font-display: swap;
      src: url('data:font/woff2;base64,') format('woff2');
      /* Здесь будет base64 шрифта Inter Regular */
    }
    
    @font-face {
      font-family: 'Inter';
      font-style: normal;
      font-weight: 600;
      font-display: swap;
      src: url('data:font/woff2;base64,') format('woff2');
      /* Здесь будет base64 шрифта Inter SemiBold */
    }
    
    @font-face {
      font-family: 'Inter';
      font-style: normal;
      font-weight: 700;
      font-display: swap;
      src: url('data:font/woff2;base64,') format('woff2');
      /* Здесь будет base64 шрифта Inter Bold */
    }
    
    /* Системные шрифты как фоллбэк */
    @font-face {
      font-family: 'System';
      font-style: normal;
      font-weight: 400;
      src: local('.SFNSText-Regular'), local('Helvetica Neue'), local('Helvetica'), local('Arial');
    }
    
    * { 
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
    }
    
    :root {
      --primary: #007aff;
      --primary-hover: #0051d5;
      --danger: #ff3b30;
      --success: #34c759;
      --warning: #ff9500;
      --bg-dark: #1c1c1e;
      --bg-medium: #2c2c2e;
      --bg-light: #f2f2f7;
      --border: #d1d1d6;
      --text: #000000;
      --text-secondary: #6c6c70;
      --safe-area-inset-top: env(safe-area-inset-top);
      --safe-area-inset-bottom: env(safe-area-inset-bottom);
    }
    
    html, body { 
      margin: 0; 
      padding: 0; 
      height: 100%; 
      overflow: hidden; 
      font-family: 'Inter', 'System', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: var(--bg-light);
      -webkit-user-select: none;
      user-select: none;
      touch-action: none;
    }
    
    #app { 
      display: flex; 
      height: 100vh;
      padding-top: var(--safe-area-inset-top);
      padding-bottom: var(--safe-area-inset-bottom);
    }
    
    #sidebar { 
      width: 320px; 
      background: #ffffff; 
      border-right: 1px solid var(--border); 
      display: flex; 
      flex-direction: column; 
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      box-shadow: 2px 0 10px rgba(0,0,0,0.05);
    }
    
    /* Адаптация для мобильных устройств */
    /* Улучшенная адаптация для мобильных устройств */
@media (max-width: 768px) {
  #app {
    flex-direction: column;
    height: 100vh;
    height: 100dvh; /* Динамическая высота для iOS */
  }
  
  #sidebar {
    width: 100%;
    height: auto;
    max-height: 60vh;
    border-right: none;
    border-bottom: 1px solid var(--border);
    position: relative;
    z-index: 20;
  }
  
  #canvas-container {
    flex: 1;
    min-height: 40vh;
  }
  
  /* Скрываем zoom control на мобильных - используем жесты */
  #zoom-control {
    display: none !important;
  }
  
  /* Увеличиваем кнопки для тач */
  button {
    min-height: 44px;
    font-size: 16px;
  }
  
  .section-content {
    padding: 16px;
  }
  
  input[type="number"], 
  input[type="text"],
  select {
    min-height: 44px;
    font-size: 16px !important;
  }
}

/* Планшеты в портретной ориентации */
@media (min-width: 769px) and (max-width: 1024px) and (orientation: portrait) {
  #sidebar {
    width: 400px;
  }
}

/* Планшеты в ландшафтной ориентации */
@media (min-width: 769px) and (max-width: 1024px) and (orientation: landscape) {
  #sidebar {
    width: 350px;
  }
  
  #canvas-wrapper {
    margin: 20px;
  }
}

/* Маленькие экраны в ландшафте */
@media (max-height: 500px) and (orientation: landscape) {
  #sidebar {
    width: 300px;
  }
  
  .sidebar-header {
    padding: 8px;
    font-size: 16px;
  }
  
  details {
    max-height: 300px;
    overflow-y: auto;
  }
}
    
    .sidebar-header {
      padding: 16px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      font-size: 18px;
      font-weight: 600;
      text-align: center;
      letter-spacing: 0.5px;
      position: sticky;
      top: 0;
      z-index: 100;
    }
    
    .autosave-indicator {
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 12px;
      color: rgba(255, 255, 255, 0.8);
      display: none;
    }
    
    .autosave-indicator.show {
      display: block;
      animation: pulse 1s ease;
    }
    
    @keyframes pulse {
      0% { opacity: 0; }
      50% { opacity: 1; }
      100% { opacity: 0; }
    }
    
    details { 
      margin: 0;
      border-bottom: 1px solid var(--border);
      background: #ffffff;
    }
    
    summary { 
      cursor: pointer; 
      padding: 12px 16px; 
      font-size: 14px; 
      font-weight: 600; 
      list-style: none;
      user-select: none;
      transition: background 0.2s;
      color: var(--text);
    }
    
    summary:hover {
      background: var(--bg-light);
    }
    
    summary::-webkit-details-marker { display: none; }
    
    summary:before { 
      content: "▶"; 
      display: inline-block; 
      width: 1em; 
      margin-right: 8px;
      transition: transform 0.2s ease;
      color: var(--text-secondary);
    }
    
    details[open] summary:before { 
      transform: rotate(90deg); 
    }
    
    .section-content { 
      padding: 12px 16px; 
      display: flex; 
      flex-direction: column;
      gap: 10px;
    }
    
    label { 
      font-size: 13px; 
      color: var(--text-secondary);
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .input-group {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    
    .input-group input[type="number"] {
      flex: 1;
    }
    
    input[type="number"], 
    input[type="color"], 
    select, 
    button, 
    input[type="file"], 
    textarea { 
      width: 100%; 
      padding: 8px 12px; 
      border: 1px solid var(--border); 
      border-radius: 8px; 
      font-size: 14px;
      transition: all 0.2s;
      background: white;
      color: var(--text);
      -webkit-appearance: none;
      appearance: none;
    }
    
    textarea, input[type="text"], input[type="number"] {
      -webkit-user-select: text;
      user-select: text;
    }
    
    input[type="number"] {
      font-weight: 500;
      letter-spacing: 0.5px;
    }
    
    input[type="number"]::-webkit-inner-spin-button,
    input[type="number"]::-webkit-outer-spin-button {
      opacity: 1;
      height: 30px;
    }
    
    input[type="number"]:focus,
    select:focus,
    textarea:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.1);
    }
    
    input[type="checkbox"] { 
      margin-right: 6px;
      width: 16px;
      height: 16px;
      cursor: pointer;
    }
    
    input[type="range"] {
      width: 100%;
      padding: 0;
      margin: 8px 0;
    }
    
    button { 
      cursor: pointer; 
      background: var(--primary); 
      color: white; 
      border: none;
      font-weight: 500;
      transition: all 0.2s;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }
    
    button:active {
      transform: scale(0.98);
    }
    
    button:hover:not(:disabled) {
      background: var(--primary-hover);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0, 122, 255, 0.3);
    }
    
    button:disabled { 
      background: var(--border); 
      cursor: not-allowed;
      opacity: 0.6;
    }
    
    button.danger {
      background: var(--danger);
    }
    
    button.danger:hover:not(:disabled) {
      background: #d70015;
      box-shadow: 0 4px 12px rgba(255, 59, 48, 0.3);
    }
    
    button.success {
      background: var(--success);
    }
    
    button.secondary {
      background: var(--text-secondary);
    }
    
    .button-group {
      display: flex;
      gap: 8px;
    }
    
    .button-group button {
      flex: 1;
    }
    
    #block-list { 
      margin-top: 12px; 
      border-top: 1px solid var(--border); 
      padding-top: 12px;
      max-height: 200px;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }
    
    .block-list-header {
      font-size: 13px;
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: 8px;
    }
    
    .block-item { 
      padding: 10px; 
      margin-bottom: 6px; 
      border: 1px solid var(--border); 
      border-radius: 6px; 
      cursor: pointer; 
      font-size: 13px; 
      background: white;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: all 0.2s;
    }
    
    .block-item:hover {
      border-color: var(--primary);
      background: #f8f9fa;
    }
    
    .block-item.selected { 
      background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
      border-color: var(--primary);
      box-shadow: 0 2px 8px rgba(0, 122, 255, 0.15);
    }
    
    .block-item-icon {
      width: 24px;
      height: 24px;
      border-radius: 4px;
      background: var(--bg-light);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
    }
    
    #canvas-container { 
      flex-grow: 1; 
      background: linear-gradient(45deg, #f0f0f0 25%, transparent 25%),
                  linear-gradient(-45deg, #f0f0f0 25%, transparent 25%),
                  linear-gradient(45deg, transparent 75%, #f0f0f0 75%),
                  linear-gradient(-45deg, transparent 75%, #f0f0f0 75%);
      background-size: 20px 20px;
      background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
      overflow: auto; 
      text-align: center; 
      white-space: nowrap; 
      position: relative;
      -webkit-overflow-scrolling: touch;
    }
    
    #canvas-wrapper { 
      display: inline-block; 
      background: #fff; 
      box-shadow: 0 10px 40px rgba(0,0,0,0.15); 
      transform-origin: top left; 
      margin: 40px;
      border-radius: 8px;
      overflow: hidden;
    }
    
    canvas { 
      display: block; 
      background: white; 
      cursor: grab;
      touch-action: none;
    }
    
    canvas.grabbing {
      cursor: grabbing;
    }
    
    #zoom-control { 
      position: absolute; 
      bottom: 20px; 
      right: 20px; 
      background: white; 
      border: 1px solid var(--border); 
      border-radius: 12px; 
      padding: 12px 16px; 
      display: flex; 
      align-items: center;
      gap: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      z-index: 10;
    }
    
    .zoom-buttons {
      display: flex;
      gap: 4px;
    }
    
    .zoom-btn {
      width: 32px;
      height: 32px;
      border-radius: 6px;
      background: var(--bg-light);
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      font-size: 18px;
      color: var(--text);
    }
    
    .zoom-btn:hover {
      background: var(--primary);
      color: white;
    }
    
    #zoom-control input[type="range"] { 
      width: 120px;
      margin: 0;
    }
    
    #zoomValue { 
      font-size: 14px;
      font-weight: 500;
      min-width: 40px;
      text-align: center;
      color: var(--text);
    }
    
    .gradient-control {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 4px;
    }
    
    .gradient-control span {
      font-size: 12px;
      color: var(--text-secondary);
      min-width: 60px;
    }
    
    .shortcuts-list {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    
    .shortcut-item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: var(--text);
    }
    
    .shortcut-item kbd {
      background: var(--bg-light);
      padding: 3px 8px;
      border-radius: 4px;
      font-family: monospace;
      font-size: 12px;
      border: 1px solid var(--border);
      min-width: fit-content;
    }
    
    .shortcut-item span {
      color: var(--text-secondary);
    }
    
    /* iOS оптимизации */
    @supports (-webkit-touch-callout: none) {
      input, textarea, select {
        font-size: 16px !important;
      }
    }
    
    /* Индикатор установки */
    .install-prompt {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: white;
      padding: 12px 20px;
      border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.15);
      z-index: 1000;
      display: none;
      align-items: center;
      gap: 12px;
    }
    
    .install-prompt.show {
      display: flex;
    }
    
    .install-prompt button {
      padding: 6px 12px;
      font-size: 14px;
    }
  </style>
</head>
<body>

<div id="app">
  <div id="sidebar">
    <div class="sidebar-header">
      <button id="toggleSidebar" style="display: none; position: absolute; right: 10px; top: 50%; transform: translateY(-50%); background: rgba(255,255,255,0.2); border: none; color: white; padding: 5px 10px; border-radius: 4px; font-size: 18px;">☰</button>
      📱 Story Editor Pro
      <span id="autosaveIndicator" class="autosave-indicator">✓ Автосохранено</span>
    </div>
    
    <details open>
      <summary>Настройки холста</summary>
      <div class="section-content">
        <label>Размер холста:</label>
        <div class="input-group">
          <input type="number" id="canvasWidth" value="1080" min="100" placeholder="Ширина">
          <span>×</span>
          <input type="number" id="canvasHeight" value="1920" min="100" placeholder="Высота">
        </div>
        <button id="resizeCanvasBtn">Применить размер</button>
        <div class="button-group">
          <button id="preset9x16" class="secondary">9:16</button>
          <button id="preset1x1" class="secondary">1:1</button>
          <button id="preset16x9" class="secondary">16:9</button>
        </div>
      </div>
    </details>

    <details>
      <summary>Фон</summary>
      <div class="section-content">
        <button id="bgUploadBtn">📷 Загрузить фон</button>
        <input type="file" id="bgUpload" accept="image/*" style="display: none;">
        <label>
          <input type="checkbox" id="moveBgMode"> 
          Режим перемещения фона
        </label>
        <button id="removeBgBtn" class="danger" style="display: none;">Удалить фон</button>
      </div>
    </details>

    <details>
      <summary>Вспомогательные линии</summary>
      <div class="section-content">
        <label>
          <input type="checkbox" id="showCenterLines"> 
          Показать центральные линии
        </label>
        <label>
          <input type="checkbox" id="showSafeZones"> 
          Показать охранные поля
        </label>
        <label style="margin-left: 24px; font-size: 12px;">
          Сверху: <span id="safeZoneTopValue">250px</span>
        </label>
        <input type="range" id="safeZoneTop" min="50" max="400" value="250" style="margin-left: 24px;">
        <label style="margin-left: 24px; font-size: 12px;">
          Снизу: <span id="safeZoneBottomValue">100px</span>
        </label>
        <input type="range" id="safeZoneBottom" min="50" max="300" value="100" style="margin-left: 24px;">
      </div>
    </details>

    <details>
      <summary>Градиенты</summary>
      <div class="section-content">
        <button id="addTopGradientBtn" class="secondary">+ Добавить градиент сверху</button>
        <button id="addBottomGradientBtn" class="secondary">+ Добавить градиент снизу</button>
        
        <div id="topGradientControls" style="display: none; margin-top: 12px;">
          <label style="font-weight: 600;">Градиент сверху:</label>
          <div class="gradient-control" style="margin-left: 24px;">
            <span>Высота:</span>
            <input type="range" id="topGradientHeight" min="100" max="600" value="300">
            <span id="topGradientHeightValue">300px</span>
          </div>
          <div class="gradient-control" style="margin-left: 24px;">
            <span>Прозрачность:</span>
            <input type="range" id="topGradientOpacity" min="0" max="100" value="50">
            <span id="topGradientOpacityValue">50%</span>
          </div>
          <div class="button-group" style="margin-left: 24px; margin-top: 8px;">
            <button id="topGradientUp" class="secondary">↑ Выше</button>
            <button id="topGradientDown" class="secondary">↓ Ниже</button>
          </div>
          <button id="removeTopGradientBtn" class="danger" style="margin-left: 24px; margin-top: 8px;">Удалить</button>
        </div>
        
        <div id="bottomGradientControls" style="display: none; margin-top: 12px;">
          <label style="font-weight: 600;">Градиент снизу:</label>
          <div class="gradient-control" style="margin-left: 24px;">
            <span>Высота:</span>
            <input type="range" id="bottomGradientHeight" min="100" max="600" value="300">
            <span id="bottomGradientHeightValue">300px</span>
          </div>
          <div class="gradient-control" style="margin-left: 24px;">
            <span>Прозрачность:</span>
            <input type="range" id="bottomGradientOpacity" min="0" max="100" value="50">
            <span id="bottomGradientOpacityValue">50%</span>
          </div>
          <div class="button-group" style="margin-left: 24px; margin-top: 8px;">
            <button id="bottomGradientUp" class="secondary">↑ Выше</button>
            <button id="bottomGradientDown" class="secondary">↓ Ниже</button>
          </div>
          <button id="removeBottomGradientBtn" class="danger" style="margin-left: 24px; margin-top: 8px;">Удалить</button>
        </div>
      </div>
    </details>

    <details>
      <summary>История действий</summary>
      <div class="section-content">
        <div class="button-group">
          <button id="undoBtn" disabled>↶ Отменить</button>
          <button id="redoBtn" disabled>↷ Повторить</button>
        </div>
        <button id="clearStorageBtn" class="danger" style="margin-top: 10px;">🗑️ Очистить автосохранение</button>
      </div>
    </details>

    <details open>
      <summary>Блоки и свойства</summary>
      <div class="section-content">
        <div class="button-group">
          <button id="addTextBtn">📝 Текст</button>
          <button id="addStickerBtn">🖼️ Картинка</button>
        </div>
        
        <div style="margin-top: 12px;">
          <label>Позиция и размер:</label>
          <div class="input-group">
            <input type="number" id="propX" disabled placeholder="X">
            <input type="number" id="propY" disabled placeholder="Y">
          </div>
          <div class="input-group">
            <input type="number" id="propW" disabled placeholder="Ширина">
            <input type="number" id="propH" disabled placeholder="Высота">
          </div>
          <label>
            <input type="checkbox" id="keepAspectRatio" checked disabled>
            Сохранять пропорции
          </label>
        </div>
        
        <div style="margin-top: 12px;">
          <label>Стиль блока:</label>
          <div class="input-group">
            <input type="color" id="propBgColor" disabled>
            <label style="flex: 1;">
              <input type="checkbox" id="propTransparentBg" disabled>
              Прозрачный фон
            </label>
          </div>
          <div class="input-group">
            <input type="number" id="propPaddingTop" value="20" disabled min="0" placeholder="Отступ сверху">
            <input type="number" id="propBorderRadius" value="0" disabled min="0" placeholder="Скругление">
          </div>
        </div>
        
        <div style="margin-top: 12px;">
          <label>Текст:</label>
          <select id="propFontFamily" disabled>
            <option value="Inter, System, sans-serif">Inter (Основной)</option>
            <option value="System, -apple-system, sans-serif">System UI</option>
            <option value="Georgia, serif">Georgia</option>
            <option value="Courier New, monospace">Courier New</option>
          </select>
          <div class="input-group">
            <label style="flex: 0; white-space: nowrap;">Размер:</label>
            <input type="number" id="propFontSize" value="48" disabled min="8" max="200" placeholder="px" style="min-width: 80px;">
            <input type="color" id="propFontColor" value="#000000" disabled style="max-width: 60px;">
          </div>
          <div class="input-group">
            <label><input type="checkbox" id="propBold" disabled> Жирный</label>
            <label><input type="checkbox" id="propItalic" disabled> Курсив</label>
          </div>
          <select id="propTextAlign" disabled>
            <option value="left">Слева</option>
            <option value="center">По центру</option>
            <option value="right">Справа</option>
          </select>
          <textarea id="propText" rows="3" disabled placeholder="Введите текст..."></textarea>
        </div>
        
        <div class="button-group">
          <button id="deleteBlockBtn" class="danger" disabled>🗑️ Удалить</button>
          <button id="duplicateBtn" disabled>📋 Копия</button>
        </div>
        <div class="button-group">
          <button id="bringForwardBtn" disabled>↑ Выше</button>
          <button id="sendBackwardBtn" disabled>↓ Ниже</button>
        </div>
        
        <div id="block-list">
          <div class="block-list-header">Список блоков:</div>
        </div>
      </div>
    </details>

    <details>
      <summary>Сохранение проекта</summary>
      <div class="section-content">
        <button id="saveProjectBtn" class="secondary">💾 Сохранить в файл</button>
        <button id="loadProjectBtn" class="secondary">📂 Загрузить из файла</button>
        <input type="file" id="loadProjectInput" accept=".json" style="display: none;">
        <div style="margin-top: 10px; font-size: 12px; color: var(--text-secondary);">
          Автосохранение происходит автоматически каждые 5 секунд
        </div>
      </div>
    </details>

    <details>
      <summary>Экспорт изображения</summary>
      <div class="section-content">
        <button id="downloadBtn" class="success">🖼️ Скачать PNG</button>
        <button id="copyBtn">📋 Копировать в буфер</button>
      </div>
    </details>

    <details>
      <summary>О приложении</summary>
      <div class="section-content">
        <div style="font-size: 12px; color: var(--text-secondary);">
          <p>Story Editor Pro v2.0</p>
          <p>PWA версия для iOS/Android</p>
          <p>Работает офлайн ✓</p>
          <button id="installBtn" class="secondary" style="display: none;">📱 Установить приложение</button>
        </div>
      </div>
    </details>
  </div>

  <div id="canvas-container">
    <div id="canvas-wrapper" style="transform: scale(0.5);">
      <canvas id="canvas" width="1080" height="1920"></canvas>
    </div>
    
    <div id="zoom-control">
      <div class="zoom-buttons">
        <button class="zoom-btn" id="zoomOut">−</button>
        <button class="zoom-btn" id="zoomReset">⟲</button>
        <button class="zoom-btn" id="zoomIn">+</button>
      </div>
      <input type="range" id="zoomSlider" min="0.1" max="3" step="0.1" value="0.5">
      <span id="zoomValue">50%</span>
    </div>
  </div>
</div>

<div id="installPrompt" class="install-prompt">
  <span>Установить Story Editor?</span>
  <button id="installConfirm">Установить</button>
  <button id="installCancel" class="secondary">Позже</button>
</div>

<script>
  // === ИНИЦИАЛИЗАЦИЯ ===
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  let canvasWidth = parseInt(document.getElementById('canvasWidth').value);
  let canvasHeight = parseInt(document.getElementById('canvasHeight').value);
  canvas.width = canvasWidth;
  canvas.height = canvasHeight;

  let scale = 0.5;
  const canvasWrapper = document.getElementById('canvas-wrapper');
  
  // Настройки
  let showCenterLines = false;
  let showSafeZones = false;
  let safeZoneTop = 250;
  let safeZoneBottom = 100;
  
  // Градиенты
  let topGradientBlock = null;
  let bottomGradientBlock = null;
  
  // Состояние
  let bgImage = new Image();
  let bgLoaded = false;
  let bgX = 0, bgY = 0, bgW = canvasWidth, bgH = canvasHeight;
  let moveBgMode = false;
  let blocks = [];
  let nextBlockId = 1;
  let selectedBlockId = null;
  let undoStack = [];
  let redoStack = [];
  const maxHistory = 50;
  
  // Автосохранение
  let autosaveTimer = null;
  const AUTOSAVE_KEY = 'storyEditorProject';
  const AUTOSAVE_INTERVAL = 5000; // 5 секунд

  // === SERVICE WORKER ДЛЯ PWA ===
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('./sw.js')
      .then(reg => console.log('Service Worker зарегистрирован'))
      .catch(err => console.log('Service Worker не зарегистрирован:', err));
  }

  // === УСТАНОВКА PWA ===
  let deferredPrompt;
  const installBtn = document.getElementById('installBtn');
  const installPrompt = document.getElementById('installPrompt');

  window.addEventListener('beforeinstallprompt', (e) => {
    e.preventDefault();
    deferredPrompt = e;
    installBtn.style.display = 'block';
    
    // Показываем промт через 30 секунд
    setTimeout(() => {
      if (deferredPrompt) {
        installPrompt.classList.add('show');
      }
    }, 30000);
  });

  installBtn.addEventListener('click', async () => {
    if (deferredPrompt) {
      deferredPrompt.prompt();
      const { outcome } = await deferredPrompt.userChoice;
      console.log(`Пользователь выбрал: ${outcome}`);
      deferredPrompt = null;
      installBtn.style.display = 'none';
    }
  });

  document.getElementById('installConfirm').addEventListener('click', async () => {
    installPrompt.classList.remove('show');
    if (deferredPrompt) {
      deferredPrompt.prompt();
      await deferredPrompt.userChoice;
      deferredPrompt = null;
    }
  });

  document.getElementById('installCancel').addEventListener('click', () => {
    installPrompt.classList.remove('show');
  });

  // Проверка, установлено ли приложение
  window.addEventListener('appinstalled', () => {
    console.log('PWA установлено');
    installBtn.style.display = 'none';
    installPrompt.classList.remove('show');
  });

  // === АВТОСОХРАНЕНИЕ В LOCALSTORAGE ===
  function saveToLocalStorage() {
    try {
      const projectData = {
        version: '2.0',
        timestamp: new Date().toISOString(),
        canvas: { width: canvasWidth, height: canvasHeight },
        background: {
          loaded: bgLoaded,
          src: bgLoaded ? bgImage.src : null,
          x: bgX, y: bgY, width: bgW, height: bgH
        },
        blocks: blocks.map(block => {
          const blockData = { ...block };
          if (block.type === 'image') {
            blockData.imageSrc = block.img.src;
            delete blockData.img;
          }
          return blockData;
        }),
        settings: {
          showCenterLines, showSafeZones,
          safeZoneTop, safeZoneBottom, zoom: scale
        }
      };
      
      const dataStr = JSON.stringify(projectData);
      
      // Проверяем размер (localStorage имеет лимит ~5-10MB)
      if (dataStr.length < 5000000) { // 5MB лимит
        localStorage.setItem(AUTOSAVE_KEY, dataStr);
        showAutosaveIndicator();
        return true;
      } else {
        console.warn('Проект слишком большой для автосохранения');
        return false;
      }
    } catch (e) {
      console.error('Ошибка автосохранения:', e);
      return false;
    }
  }

  function loadFromLocalStorage() {
    try {
      const dataStr = localStorage.getItem(AUTOSAVE_KEY);
      if (!dataStr) return false;
      
      const projectData = JSON.parse(dataStr);
      if (!projectData.version) return false;
      
      // Восстановление проекта
      restoreProject(projectData);
      return true;
    } catch (e) {
      console.error('Ошибка загрузки автосохранения:', e);
      return false;
    }
  }

  function showAutosaveIndicator() {
    const indicator = document.getElementById('autosaveIndicator');
    indicator.classList.add('show');
    setTimeout(() => {
      indicator.classList.remove('show');
    }, 2000);
  }

  function startAutosave() {
    stopAutosave();
    autosaveTimer = setInterval(() => {
      if (blocks.length > 0 || bgLoaded) {
        saveToLocalStorage();
      }
    }, AUTOSAVE_INTERVAL);
  }

  function stopAutosave() {
    if (autosaveTimer) {
      clearInterval(autosaveTimer);
      autosaveTimer = null;
    }
  }

  document.getElementById('clearStorageBtn').addEventListener('click', () => {
    if (confirm('Удалить автосохраненный проект? Это действие нельзя отменить.')) {
      localStorage.removeItem(AUTOSAVE_KEY);
      alert('Автосохранение очищено');
    }
  });

// === ФУНКЦИИ УПРАВЛЕНИЯ МАСШТАБОМ (уже есть в коде) ===
// Этот блок уже добавлен, пропускаем

// === ОБРАБОТЧИКИ ПРЕСЕТОВ ===
document.getElementById('preset9x16').addEventListener('click', () => {
  document.getElementById('canvasWidth').value = 1080;
  document.getElementById('canvasHeight').value = 1920;
  document.getElementById('resizeCanvasBtn').click();
});

document.getElementById('preset1x1').addEventListener('click', () => {
  document.getElementById('canvasWidth').value = 1080;
  document.getElementById('canvasHeight').value = 1080;
  document.getElementById('resizeCanvasBtn').click();
});

document.getElementById('preset16x9').addEventListener('click', () => {
  document.getElementById('canvasWidth').value = 1920;
  document.getElementById('canvasHeight').value = 1080;
  document.getElementById('resizeCanvasBtn').click();
});

// === ОБРАБОТЧИКИ ВСПОМОГАТЕЛЬНЫХ ЛИНИЙ ===
document.getElementById('showCenterLines').addEventListener('change', e => {
  showCenterLines = e.target.checked;
  redrawCanvas();
});

document.getElementById('showSafeZones').addEventListener('change', e => {
  showSafeZones = e.target.checked;
  redrawCanvas();
});

document.getElementById('safeZoneTop').addEventListener('input', e => {
  safeZoneTop = parseInt(e.target.value);
  document.getElementById('safeZoneTopValue').textContent = safeZoneTop + 'px';
  if (showSafeZones) redrawCanvas();
});

document.getElementById('safeZoneBottom').addEventListener('input', e => {
  safeZoneBottom = parseInt(e.target.value);
  document.getElementById('safeZoneBottomValue').textContent = safeZoneBottom + 'px';
  if (showSafeZones) redrawCanvas();
});

// === ОБРАБОТЧИКИ ГРАДИЕНТОВ ===
document.getElementById('addTopGradientBtn').addEventListener('click', () => {
  if (!topGradientBlock) {
    pushStateToUndo();
    topGradientBlock = {
      id: nextBlockId++,
      type: 'gradient',
      gradientType: 'top',
      height: 300,
      opacity: 0.5,
      zIndex: blocks.length + 1
    };
    blocks.push(topGradientBlock);
    document.getElementById('topGradientControls').style.display = 'block';
    document.getElementById('addTopGradientBtn').style.display = 'none';
    refreshBlockList();
    redrawCanvas();
  }
});

document.getElementById('addBottomGradientBtn').addEventListener('click', () => {
  if (!bottomGradientBlock) {
    pushStateToUndo();
    bottomGradientBlock = {
      id: nextBlockId++,
      type: 'gradient',
      gradientType: 'bottom',
      height: 300,
      opacity: 0.5,
      zIndex: blocks.length + 1
    };
    blocks.push(bottomGradientBlock);
    document.getElementById('bottomGradientControls').style.display = 'block';
    document.getElementById('addBottomGradientBtn').style.display = 'none';
    refreshBlockList();
    redrawCanvas();
  }
});

document.getElementById('removeTopGradientBtn').addEventListener('click', () => {
  if (topGradientBlock) {
    pushStateToUndo();
    blocks = blocks.filter(b => b.id !== topGradientBlock.id);
    topGradientBlock = null;
    document.getElementById('topGradientControls').style.display = 'none';
    document.getElementById('addTopGradientBtn').style.display = 'block';
    refreshBlockList();
    redrawCanvas();
  }
});

document.getElementById('removeBottomGradientBtn').addEventListener('click', () => {
  if (bottomGradientBlock) {
    pushStateToUndo();
    blocks = blocks.filter(b => b.id !== bottomGradientBlock.id);
    bottomGradientBlock = null;
    document.getElementById('bottomGradientControls').style.display = 'none';
    document.getElementById('addBottomGradientBtn').style.display = 'block';
    refreshBlockList();
    redrawCanvas();
  }
});

document.getElementById('topGradientHeight').addEventListener('input', e => {
  if (topGradientBlock) {
    topGradientBlock.height = parseInt(e.target.value);
    document.getElementById('topGradientHeightValue').textContent = topGradientBlock.height + 'px';
    redrawCanvas();
  }
});

document.getElementById('topGradientOpacity').addEventListener('input', e => {
  if (topGradientBlock) {
    topGradientBlock.opacity = parseInt(e.target.value) / 100;
    document.getElementById('topGradientOpacityValue').textContent = e.target.value + '%';
    redrawCanvas();
  }
});

document.getElementById('bottomGradientHeight').addEventListener('input', e => {
  if (bottomGradientBlock) {
    bottomGradientBlock.height = parseInt(e.target.value);
    document.getElementById('bottomGradientHeightValue').textContent = bottomGradientBlock.height + 'px';
    redrawCanvas();
  }
});

document.getElementById('bottomGradientOpacity').addEventListener('input', e => {
  if (bottomGradientBlock) {
    bottomGradientBlock.opacity = parseInt(e.target.value) / 100;
    document.getElementById('bottomGradientOpacityValue').textContent = e.target.value + '%';
    redrawCanvas();
  }
});

document.getElementById('topGradientUp').addEventListener('click', () => {
  if (topGradientBlock) {
    pushStateToUndo();
    topGradientBlock.zIndex = Math.max(...blocks.map(x => x.zIndex)) + 1;
    redrawCanvas();
  }
});

document.getElementById('topGradientDown').addEventListener('click', () => {
  if (topGradientBlock) {
    pushStateToUndo();
    topGradientBlock.zIndex = Math.min(...blocks.map(x => x.zIndex)) - 1;
    redrawCanvas();
  }
});

document.getElementById('bottomGradientUp').addEventListener('click', () => {
  if (bottomGradientBlock) {
    pushStateToUndo();
    bottomGradientBlock.zIndex = Math.max(...blocks.map(x => x.zIndex)) + 1;
    redrawCanvas();
  }
});

document.getElementById('bottomGradientDown').addEventListener('click', () => {
  if (bottomGradientBlock) {
    pushStateToUndo();
    bottomGradientBlock.zIndex = Math.min(...blocks.map(x => x.zIndex)) - 1;
    redrawCanvas();
  }
});

// === ФУНКЦИИ ИСТОРИИ ===
function pushStateToUndo() {
  const state = {
    blocks: JSON.parse(JSON.stringify(blocks, (key, value) => {
      if (value && value instanceof Image) return { __img__: true, src: value.src };
      return value;
    })),
    bgLoaded, bgX, bgY, bgW, bgH, canvasWidth, canvasHeight, bgSrc: bgLoaded ? bgImage.src : null
  };
  undoStack.push(state);
  if (undoStack.length > maxHistory) undoStack.shift();
  redoStack = [];
  updateUndoRedoButtons();
}

function restoreState(state) {
  blocks = state.blocks.map(b => {
    if (b.type === 'image') {
      const img = new Image();
      img.src = b.img.src;
      return { ...b, img };
    }
    return { ...b };
  });
  
  // Восстанавливаем ссылки на градиентные блоки
  topGradientBlock = blocks.find(b => b.type === 'gradient' && b.gradientType === 'top') || null;
  bottomGradientBlock = blocks.find(b => b.type === 'gradient' && b.gradientType === 'bottom') || null;
  
  // Обновляем UI для градиентов
  if (topGradientBlock) {
    document.getElementById('topGradientControls').style.display = 'block';
    document.getElementById('addTopGradientBtn').style.display = 'none';
    document.getElementById('topGradientHeight').value = topGradientBlock.height;
    document.getElementById('topGradientHeightValue').textContent = topGradientBlock.height + 'px';
    document.getElementById('topGradientOpacity').value = topGradientBlock.opacity * 100;
    document.getElementById('topGradientOpacityValue').textContent = (topGradientBlock.opacity * 100) + '%';
  } else {
    document.getElementById('topGradientControls').style.display = 'none';
    document.getElementById('addTopGradientBtn').style.display = 'block';
  }
  
  if (bottomGradientBlock) {
    document.getElementById('bottomGradientControls').style.display = 'block';
    document.getElementById('addBottomGradientBtn').style.display = 'none';
    document.getElementById('bottomGradientHeight').value = bottomGradientBlock.height;
    document.getElementById('bottomGradientHeightValue').textContent = bottomGradientBlock.height + 'px';
    document.getElementById('bottomGradientOpacity').value = bottomGradientBlock.opacity * 100;
    document.getElementById('bottomGradientOpacityValue').textContent = (bottomGradientBlock.opacity * 100) + '%';
  } else {
    document.getElementById('bottomGradientControls').style.display = 'none';
    document.getElementById('addBottomGradientBtn').style.display = 'block';
  }
  
  if (state.bgLoaded && state.bgSrc) {
    bgImage.src = state.bgSrc;
    bgImage.onload = () => {
      bgLoaded = true;
      bgX = state.bgX;
      bgY = state.bgY;
      bgW = state.bgW;
      bgH = state.bgH;
      redrawCanvas();
    };
  } else {
    bgLoaded = false;
    bgX = state.bgX;
    bgY = state.bgY;
    bgW = state.bgW;
    bgH = state.bgH;
  }
  
  canvasWidth = state.canvasWidth;
  canvasHeight = state.canvasHeight;
  canvas.width = canvasWidth;
  canvas.height = canvasHeight;
  document.getElementById('canvasWidth').value = canvasWidth;
  document.getElementById('canvasHeight').value = canvasHeight;
  selectedBlockId = null;
  deactivateBlockSelection();
  refreshBlockList();
  redrawCanvas();
}

function undo() {
  if (!undoStack.length) return;
  const currentState = {
    blocks: JSON.parse(JSON.stringify(blocks, (key, value) => {
      if (value && value instanceof Image) return { __img__: true, src: value.src };
      return value;
    })),
    bgLoaded, bgX, bgY, bgW, bgH, canvasWidth, canvasHeight, bgSrc: bgLoaded ? bgImage.src : null
  };
  redoStack.push(currentState);
  const prevState = undoStack.pop();
  restoreState(prevState);
  updateUndoRedoButtons();
}

function redo() {
  if (!redoStack.length) return;
  const currentState = {
    blocks: JSON.parse(JSON.stringify(blocks, (key, value) => {
      if (value && value instanceof Image) return { __img__: true, src: value.src };
      return value;
    })),
    bgLoaded, bgX, bgY, bgW, bgH, canvasWidth, canvasHeight, bgSrc: bgLoaded ? bgImage.src : null
  };
  undoStack.push(currentState);
  const nextState = redoStack.pop();
  restoreState(nextState);
  updateUndoRedoButtons();
}

function updateUndoRedoButtons() {
  document.getElementById('undoBtn').disabled = !undoStack.length;
  document.getElementById('redoBtn').disabled = !redoStack.length;
}

document.getElementById('undoBtn').addEventListener('click', undo);
document.getElementById('redoBtn').addEventListener('click', redo);

// === ФУНКЦИИ ОТРИСОВКИ ===
function getBlockById(id) { 
  return blocks.find(b => b.id === id); 
}

function sortBlocks() { 
  blocks.sort((a, b) => a.zIndex - b.zIndex); 
}

// Функция для отрисовки вспомогательных линий
function drawGuides(ctx) {
  ctx.save();
  
  // Центральные линии
  if (showCenterLines) {
    ctx.strokeStyle = 'rgba(255, 0, 255, 0.5)';
    ctx.lineWidth = 1;
    ctx.setLineDash([10, 5]);
    
    // Вертикальная центральная линия
    ctx.beginPath();
    ctx.moveTo(canvasWidth / 2, 0);
    ctx.lineTo(canvasWidth / 2, canvasHeight);
    ctx.stroke();
    
    // Горизонтальная центральная линия
    ctx.beginPath();
    ctx.moveTo(0, canvasHeight / 2);
    ctx.lineTo(canvasWidth, canvasHeight / 2);
    ctx.stroke();
  }
  
  // Охранные поля
  if (showSafeZones) {
    ctx.strokeStyle = 'rgba(255, 0, 0, 0.6)';
    ctx.fillStyle = 'rgba(255, 0, 0, 0.1)';
    ctx.lineWidth = 2;
    ctx.setLineDash([15, 5]);
    
    // Верхнее охранное поле
    ctx.fillRect(0, 0, canvasWidth, safeZoneTop);
    ctx.beginPath();
    ctx.moveTo(0, safeZoneTop);
    ctx.lineTo(canvasWidth, safeZoneTop);
    ctx.stroke();
    
    // Нижнее охранное поле
    ctx.fillRect(0, canvasHeight - safeZoneBottom, canvasWidth, safeZoneBottom);
    ctx.beginPath();
    ctx.moveTo(0, canvasHeight - safeZoneBottom);
    ctx.lineTo(canvasWidth, canvasHeight - safeZoneBottom);
    ctx.stroke();
    
    // Добавляем подписи к охранным полям
    ctx.setLineDash([]);
    ctx.font = '14px Inter, sans-serif';
    ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
    ctx.fillText('Охранное поле (верх)', 10, safeZoneTop - 10);
    ctx.fillText('Охранное поле (низ)', 10, canvasHeight - safeZoneBottom + 20);
  }
  
  ctx.restore();
}

function redrawCanvas(forExport = false) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Рисуем фон
  if (bgLoaded) {
    ctx.drawImage(bgImage, bgX, bgY, bgW, bgH);
  } else {
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }
  
  // Сортируем и рисуем все блоки
  sortBlocks();
  for (let block of blocks) {
    ctx.save();
    
    // Рисуем градиенты
    if (block.type === 'gradient') {
      if (block.gradientType === 'top') {
        const gradient = ctx.createLinearGradient(0, 0, 0, block.height);
        gradient.addColorStop(0, `rgba(0, 0, 0, ${block.opacity})`);
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvasWidth, block.height);
      } else if (block.gradientType === 'bottom') {
        const gradient = ctx.createLinearGradient(0, canvasHeight - block.height, 0, canvasHeight);
        gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
        gradient.addColorStop(1, `rgba(0, 0, 0, ${block.opacity})`);
        ctx.fillStyle = gradient;
        ctx.fillRect(0, canvasHeight - block.height, canvasWidth, block.height);
      }
    }
    
    // Рисуем текстовые блоки
    if (block.type === 'text') {
      if (block.bgColor && block.bgColor !== 'rgba(0,0,0,0)') {
        ctx.fillStyle = block.bgColor;
        if (block.borderRadius > 0) {
          roundRect(ctx, block.x, block.y, block.w, block.h, block.borderRadius, true, false);
        } else {
          ctx.fillRect(block.x, block.y, block.w, block.h);
        }
      }
      let style = '';
      if (block.italic) style += 'italic ';
      if (block.bold) style += 'bold ';
      style += `${block.fontSize}px ${block.fontFamily}`;
      ctx.font = style;
      ctx.fillStyle = block.fontColor;
      ctx.textAlign = block.textAlign;
      ctx.textBaseline = 'top';
      let textX = block.x + (block.textAlign === 'center' ? block.w / 2 : block.textAlign === 'right' ? block.w - 10 : 10);
      let lines = block.text.split('\n');
      let lineHeight = block.fontSize * 1.2;
      for (let i = 0; i < lines.length; i++) {
        ctx.fillText(lines[i], textX, block.y + block.paddingTop + i * lineHeight);
      }
    }
    
    // Рисуем изображения
    if (block.type === 'image') {
      ctx.drawImage(block.img, block.x, block.y, block.w, block.h);
    }
    
    // Рисуем выделение для обычных блоков (не градиентов)
    if (block.id === selectedBlockId && !moveBgMode && !forExport && block.type !== 'gradient') {
      ctx.strokeStyle = '#007aff';
      ctx.lineWidth = 2;
      ctx.setLineDash([6, 4]);
      ctx.strokeRect(block.x - 2, block.y - 2, block.w + 4, block.h + 4);
      ctx.setLineDash([]);
      drawResizeHandles(ctx, block);
    }
    
    ctx.restore();
  }
  
  // Рисуем вспомогательные линии (только если не экспорт)
  if (!forExport) {
    drawGuides(ctx);
  }
}

function drawResizeHandles(ctx, block) {
  const handles = getResizeHandles(block);
  ctx.fillStyle = '#007aff';
  ctx.strokeStyle = '#ffffff';
  ctx.lineWidth = 2;
  
  for (let handle of handles) {
    ctx.beginPath();
    if (['n', 's'].includes(handle.position)) {
      ctx.roundRect(handle.x - 8, handle.y - 4, 16, 8, 4);
    } else if (['e', 'w'].includes(handle.position)) {
      ctx.roundRect(handle.x - 4, handle.y - 8, 8, 16, 4);
    } else {
      ctx.arc(handle.x, handle.y, 6, 0, Math.PI * 2);
    }
    ctx.fill();
    ctx.stroke();
  }
}

function getResizeHandles(block) {
  return [
    { x: block.x, y: block.y, position: 'nw' },
    { x: block.x + block.w / 2, y: block.y, position: 'n' },
    { x: block.x + block.w, y: block.y, position: 'ne' },
    { x: block.x + block.w, y: block.y + block.h / 2, position: 'e' },
    { x: block.x + block.w, y: block.y + block.h, position: 'se' },
    { x: block.x + block.w / 2, y: block.y + block.h, position: 's' },
    { x: block.x, y: block.y + block.h, position: 'sw' },
    { x: block.x, y: block.y + block.h / 2, position: 'w' }
  ];
}

function roundRect(ctx, x, y, w, h, r, fill, stroke) {
  if (w < 2 * r) r = w / 2;
  if (h < 2 * r) r = h / 2;
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + w, y, r);
  ctx.closePath();
  if (fill) ctx.fill();
  if (stroke) ctx.stroke();
}

// === УПРАВЛЕНИЕ БЛОКАМИ ===
const blockListDiv = document.getElementById('block-list');

function refreshBlockList() {
  Array.from(blockListDiv.children).forEach(ch => {
    if (ch.classList.contains('block-item')) blockListDiv.removeChild(ch);
  });
  
  for (let block of blocks) {
    const div = document.createElement('div');
    div.className = 'block-item';
    if (block.id === selectedBlockId) div.classList.add('selected');
    
    const icon = document.createElement('div');
    icon.className = 'block-item-icon';
    
    let text = document.createElement('span');
    
    if (block.type === 'text') {
      icon.textContent = '📝';
      text.textContent = `Текст: ${block.text.substring(0, 20)}${block.text.length > 20 ? '...' : ''}`;
    } else if (block.type === 'image') {
      icon.textContent = '🖼️';
      text.textContent = `Изображение ${block.id}`;
    } else if (block.type === 'gradient') {
      icon.textContent = '🌈';
      text.textContent = block.gradientType === 'top' ? 'Градиент сверху' : 'Градиент снизу';
    }
    
    div.appendChild(icon);
    div.appendChild(text);
    
    div.onclick = () => {
      if (!moveBgMode && block.type !== 'gradient') {
        selectBlock(block.id);
        redrawCanvas();
      }
    };
    
    blockListDiv.appendChild(div);
  }
}

function selectBlock(id) {
  selectedBlockId = id;
  const b = getBlockById(id);
  
  ['propX','propY','propW','propH','keepAspectRatio'].forEach(idf => {
    document.getElementById(idf).disabled = false;
  });
  
  ['propBgColor','propTransparentBg','propPaddingTop','propBorderRadius',
   'propFontFamily','propFontSize','propFontColor','propBold','propItalic',
   'propTextAlign','propText'].forEach(idf => {
    document.getElementById(idf).disabled = (b.type !== 'text');
  });
  
  ['deleteBlockBtn','duplicateBtn','bringForwardBtn','sendBackwardBtn'].forEach(idf => {
    document.getElementById(idf).disabled = false;
  });
  
  document.getElementById('propX').value = Math.round(b.x);
  document.getElementById('propY').value = Math.round(b.y);
  document.getElementById('propW').value = Math.round(b.w);
  document.getElementById('propH').value = Math.round(b.h);
  document.getElementById('keepAspectRatio').checked = b.type === 'image';
  
  if (b.type === 'text') {
    document.getElementById('propBgColor').value = rgbaToHex(b.bgColor);
    document.getElementById('propTransparentBg').checked = (b.bgColor === 'rgba(0,0,0,0)');
    document.getElementById('propPaddingTop').value = b.paddingTop;
    document.getElementById('propBorderRadius').value = b.borderRadius;
    document.getElementById('propFontFamily').value = b.fontFamily;
    document.getElementById('propFontSize').value = b.fontSize;
    document.getElementById('propFontColor').value = b.fontColor;
    document.getElementById('propBold').checked = b.bold;
    document.getElementById('propItalic').checked = b.italic;
    document.getElementById('propTextAlign').value = b.textAlign;
    document.getElementById('propText').value = b.text;
  }
  
  refreshBlockList();
}

function deactivateBlockSelection() {
  selectedBlockId = null;
  ['propX','propY','propW','propH','keepAspectRatio','propBgColor',
   'propTransparentBg','propPaddingTop','propBorderRadius','propFontFamily',
   'propFontSize','propFontColor','propBold','propItalic','propTextAlign',
   'propText','deleteBlockBtn','duplicateBtn','bringForwardBtn','sendBackwardBtn'].forEach(idf => {
    document.getElementById(idf).disabled = true;
  });
  refreshBlockList();
  redrawCanvas();
}

function updateSelectedBlockProps() {
  if (selectedBlockId == null) return;
  const b = getBlockById(selectedBlockId);
  const keepAspect = document.getElementById('keepAspectRatio').checked;
  
  const newX = parseInt(document.getElementById('propX').value) || b.x;
  const newY = parseInt(document.getElementById('propY').value) || b.y;
  let newW = parseInt(document.getElementById('propW').value) || b.w;
  let newH = parseInt(document.getElementById('propH').value) || b.h;
  
  if (b.type === 'image' && keepAspect && b.aspectRatio) {
    if (this.id === 'propW') {
      newH = newW / b.aspectRatio;
      document.getElementById('propH').value = Math.round(newH);
    } else if (this.id === 'propH') {
      newW = newH * b.aspectRatio;
      document.getElementById('propW').value = Math.round(newW);
    }
  }
  
  b.x = newX;
  b.y = newY;
  b.w = newW;
  b.h = newH;
  
  if (b.type === 'text') {
    if (document.getElementById('propTransparentBg').checked) {
      b.bgColor = 'rgba(0,0,0,0)';
    } else {
      b.bgColor = hexToRgba(document.getElementById('propBgColor').value, 0.9);
    }
    b.paddingTop = parseInt(document.getElementById('propPaddingTop').value) || 0;
    b.borderRadius = parseInt(document.getElementById('propBorderRadius').value) || 0;
    b.fontFamily = document.getElementById('propFontFamily').value;
    b.fontSize = parseInt(document.getElementById('propFontSize').value) || b.fontSize;
    b.fontColor = document.getElementById('propFontColor').value;
    b.bold = document.getElementById('propBold').checked;
    b.italic = document.getElementById('propItalic').checked;
    b.textAlign = document.getElementById('propTextAlign').value;
    b.text = document.getElementById('propText').value;
  }
  
  redrawCanvas();
}

// === ДОБАВЛЕНИЕ БЛОКОВ ===
document.getElementById('addTextBtn').addEventListener('click', () => {
  pushStateToUndo();
  const newBlock = {
    id: nextBlockId++,
    type: 'text',
    x: 50,
    y: 50,
    w: 400,
    h: 150,
    zIndex: blocks.length + 1,
    text: 'Новый текст',
    fontFamily: 'Inter, System, sans-serif',
    fontSize: 48,
    fontColor: '#000000',
    bold: false,
    italic: false,
    textAlign: 'left',
    bgColor: 'rgba(255,255,255,0.9)',
    borderRadius: 8,
    paddingTop: 20
  };
  blocks.push(newBlock);
  selectBlock(newBlock.id);
  refreshBlockList();
  redrawCanvas();
});

document.getElementById('addStickerBtn').addEventListener('click', () => {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = 'image/*';
  input.onchange = e => {
    const file = e.target.files[0];
    if (!file) return;
    const img = new Image();
    const reader = new FileReader();
    reader.onload = ev => {
      img.src = ev.target.result;
      img.onload = () => {
        pushStateToUndo();
        const aspect = img.width / img.height;
        const w0 = 300;
        const h0 = w0 / aspect;
        const newBlock = {
          id: nextBlockId++,
          type: 'image',
          img: img,
          x: 100,
          y: 100,
          w: w0,
          h: h0,
          zIndex: blocks.length + 1,
          aspectRatio: aspect
        };
        blocks.push(newBlock);
        selectBlock(newBlock.id);
        refreshBlockList();
        redrawCanvas();
      };
    };
    reader.readAsDataURL(file);
  };
  input.click();
});

// === ОБРАБОТЧИКИ СВОЙСТВ ===
['propX','propY','propW','propH'].forEach(idf => {
  const el = document.getElementById(idf);
  el.addEventListener('input', updateSelectedBlockProps);
  el.addEventListener('blur', () => pushStateToUndo());
});

['propBgColor','propTransparentBg','propPaddingTop','propBorderRadius',
 'propFontFamily','propFontSize','propFontColor','propBold','propItalic',
 'propTextAlign','propText'].forEach(idf => {
  const el = document.getElementById(idf);
  el.addEventListener('input', updateSelectedBlockProps);
  el.addEventListener('change', () => pushStateToUndo());
});

// === ОПЕРАЦИИ С БЛОКАМИ ===
document.getElementById('deleteBlockBtn').addEventListener('click', () => {
  if (selectedBlockId == null) return;
  pushStateToUndo();
  blocks = blocks.filter(b => b.id !== selectedBlockId);
  selectedBlockId = null;
  deactivateBlockSelection();
  refreshBlockList();
  redrawCanvas();
});

function duplicateBlock() {
  if (selectedBlockId == null) return;
  pushStateToUndo();
  const original = getBlockById(selectedBlockId);
  const newBlock = {
    ...original,
    id: nextBlockId++,
    x: original.x + 20,
    y: original.y + 20,
    zIndex: Math.max(...blocks.map(x => x.zIndex)) + 1
  };
  if (original.type === 'image') {
    newBlock.img = original.img;
  }
  blocks.push(newBlock);
  selectBlock(newBlock.id);
  refreshBlockList();
  redrawCanvas();
}

document.getElementById('duplicateBtn').addEventListener('click', duplicateBlock);

document.getElementById('bringForwardBtn').addEventListener('click', () => {
  if (selectedBlockId == null) return;
  pushStateToUndo();
  const b = getBlockById(selectedBlockId);
  b.zIndex = Math.max(...blocks.map(x => x.zIndex)) + 1;
  redrawCanvas();
  refreshBlockList();
});

document.getElementById('sendBackwardBtn').addEventListener('click', () => {
  if (selectedBlockId == null) return;
  pushStateToUndo();
  const b = getBlockById(selectedBlockId);
  b.zIndex = Math.min(...blocks.map(x => x.zIndex)) - 1;
  redrawCanvas();
  refreshBlockList();
});

// === РАБОТА С МЫШЬЮ И TOUCH ===
let isDragging = false;
let isResizing = false;
let dragOffsetX = 0, dragOffsetY = 0;
let draggingBg = false, draggingBlock = false;
let resizeHandle = null;
let originalBlock = null;
let touchStartX = 0, touchStartY = 0;

// Универсальная функция для получения координат
function getEventCoords(e) {
  if (e.touches && e.touches.length > 0) {
    return { x: e.touches[0].clientX, y: e.touches[0].clientY };
  }
  return { x: e.clientX, y: e.clientY };
}

// Обработчик начала взаимодействия (мышь и touch)
function handleStart(e) {
  e.preventDefault();
  const coords = getEventCoords(e);
  const rect = canvas.getBoundingClientRect();
  const mx = (coords.x - rect.left) / scale;
  const my = (coords.y - rect.top) / scale;
  
  if (e.touches) {
    touchStartX = coords.x;
    touchStartY = coords.y;
  }
  
  if (moveBgMode && bgLoaded) {
    if (mx >= bgX && mx <= bgX + bgW && my >= bgY && my <= bgY + bgH) {
      draggingBg = true;
      dragOffsetX = mx - bgX;
      dragOffsetY = my - bgY;
      isDragging = true;
      canvas.classList.add('grabbing');
    }
    return;
  }
  
  // Проверка ручек изменения размера
  if (selectedBlockId) {
    const block = getBlockById(selectedBlockId);
    const handles = getResizeHandles(block);
    for (let handle of handles) {
      const dist = Math.sqrt((mx - handle.x) ** 2 + (my - handle.y) ** 2);
      if (dist < 15) { // Увеличен радиус для touch
        isResizing = true;
        resizeHandle = handle.position;
        originalBlock = { ...block };
        return;
      }
    }
  }
  
  // Проверка выбора блока
  let hitBlock = null;
  for (let i = blocks.length - 1; i >= 0; i--) {
    const b = blocks[i];
    if (b.type === 'gradient') continue;
    if (mx >= b.x && mx <= b.x + b.w && my >= b.y && my <= b.y + b.h) {
      hitBlock = b;
      break;
    }
  }
  
  if (hitBlock) {
    selectBlock(hitBlock.id);
    draggingBlock = true;
    dragOffsetX = mx - hitBlock.x;
    dragOffsetY = my - hitBlock.y;
    isDragging = true;
    canvas.classList.add('grabbing');
  } else {
    deactivateBlockSelection();
  }
  
  redrawCanvas();
}

// === ПОДДЕРЖКА ЖЕСТОВ МАСШТАБИРОВАНИЯ ===
let lastTouchDistance = 0;
let isPinching = false;

function getTouchDistance(touches) {
  if (touches.length < 2) return 0;
  const dx = touches[0].clientX - touches[1].clientX;
  const dy = touches[0].clientY - touches[1].clientY;
  return Math.sqrt(dx * dx + dy * dy);
}

// Добавить в handleMove после строки "const coords = getEventCoords(e);"
function handleTouchMove(e) {
  if (e.touches && e.touches.length === 2) {
    e.preventDefault();
    const distance = getTouchDistance(e.touches);
    
    if (!isPinching) {
      isPinching = true;
      lastTouchDistance = distance;
      return;
    }
    
    const delta = distance - lastTouchDistance;
    const scaleSpeed = 0.01;
    scale = Math.min(3, Math.max(0.1, scale + (delta * scaleSpeed)));
    
    document.getElementById('zoomSlider').value = scale;
    updateZoom();
    
    lastTouchDistance = distance;
    return;
  } else if (e.touches && e.touches.length === 1 && !isPinching) {
    handleMove(e);
  }
}

// Добавить обработчик окончания пинча
canvas.addEventListener('touchend', (e) => {
  if (e.touches.length < 2) {
    isPinching = false;
    lastTouchDistance = 0;
  }
  handleEnd(e);
});

// Заменить существующий обработчик touchmove
canvas.removeEventListener('touchmove', handleMove);
canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
  
// Обработчик перемещения (мышь и touch)
function handleMove(e) {
  const coords = getEventCoords(e);
  const rect = canvas.getBoundingClientRect();
  const mx = (coords.x - rect.left) / scale;
  const my = (coords.y - rect.top) / scale;
  
  // Обновление курсора (только для мыши)
  if (!e.touches && !isDragging && !isResizing && selectedBlockId && !moveBgMode) {
    const block = getBlockById(selectedBlockId);
    const handles = getResizeHandles(block);
    let onHandle = false;
    for (let handle of handles) {
      const dist = Math.sqrt((mx - handle.x) ** 2 + (my - handle.y) ** 2);
      if (dist < 10) {
        onHandle = true;
        const cursorMap = {
          'nw': 'nwse-resize', 'ne': 'nesw-resize',
          'sw': 'nesw-resize', 'se': 'nwse-resize',
          'n': 'ns-resize', 's': 'ns-resize',
          'e': 'ew-resize', 'w': 'ew-resize'
        };
        canvas.style.cursor = cursorMap[handle.position];
        break;
      }
    }
    if (!onHandle) {
      canvas.style.cursor = 'grab';
    }
  }
  
  // Изменение размера
  if (isResizing && selectedBlockId) {
    const block = getBlockById(selectedBlockId);
    const keepAspect = document.getElementById('keepAspectRatio').checked && block.type === 'image';
    
    switch(resizeHandle) {
      case 'se':
        block.w = Math.max(50, mx - block.x);
        if (keepAspect) {
          block.h = block.w / block.aspectRatio;
        } else {
          block.h = Math.max(50, my - block.y);
        }
        break;
      case 'nw':
        const newW = Math.max(50, originalBlock.x + originalBlock.w - mx);
        const newH = keepAspect ? newW / block.aspectRatio : Math.max(50, originalBlock.y + originalBlock.h - my);
        block.x = originalBlock.x + originalBlock.w - newW;
        block.y = originalBlock.y + originalBlock.h - newH;
        block.w = newW;
        block.h = newH;
        break;
      // Остальные кейсы аналогично...
    }
    
    document.getElementById('propX').value = Math.round(block.x);
    document.getElementById('propY').value = Math.round(block.y);
    document.getElementById('propW').value = Math.round(block.w);
    document.getElementById('propH').value = Math.round(block.h);
    
    redrawCanvas();
    return;
  }
  
  if (!isDragging) return;
  
  if (draggingBg) {
    bgX = mx - dragOffsetX;
    bgY = my - dragOffsetY;
    redrawCanvas();
    return;
  }
  
  if (draggingBlock && selectedBlockId != null) {
    const b = getBlockById(selectedBlockId);
    b.x = mx - dragOffsetX;
    b.y = my - dragOffsetY;
    document.getElementById('propX').value = Math.round(b.x);
    document.getElementById('propY').value = Math.round(b.y);
    redrawCanvas();
  }
}

// Обработчик окончания взаимодействия
function handleEnd() {
  if (isDragging || isResizing) pushStateToUndo();
  isDragging = false;
  isResizing = false;
  draggingBg = false;
  draggingBlock = false;
  resizeHandle = null;
  originalBlock = null;
  canvas.classList.remove('grabbing');
  if (!moveBgMode) canvas.style.cursor = 'grab';
}

// Добавляем обработчики для мыши
canvas.addEventListener('mousedown', handleStart);
canvas.addEventListener('mousemove', handleMove);
canvas.addEventListener('mouseup', handleEnd);
canvas.addEventListener('mouseleave', handleEnd);

// Добавляем обработчики для touch
canvas.addEventListener('touchstart', handleStart, { passive: false });
canvas.addEventListener('touchmove', handleMove, { passive: false });
canvas.addEventListener('touchend', handleEnd);
canvas.addEventListener('touchcancel', handleEnd);

// === РАБОТА С ФОНОМ ===
document.getElementById('moveBgMode').addEventListener('change', e => {
  moveBgMode = e.target.checked;
  if (moveBgMode) {
    deactivateBlockSelection();
    canvas.style.cursor = 'move';
  } else {
    canvas.style.cursor = 'grab';
  }
});

document.getElementById('bgUploadBtn').addEventListener('click', () => {
  document.getElementById('bgUpload').click();
});

document.getElementById('bgUpload').addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = ev => {
    pushStateToUndo();
    bgImage = new Image();
    bgImage.src = ev.target.result;
    bgImage.onload = () => {
      bgLoaded = true;
      const aspect = bgImage.width / bgImage.height;
      const canvasAspect = canvasWidth / canvasHeight;
      
      if (aspect > canvasAspect) {
        bgW = canvasWidth;
        bgH = canvasWidth / aspect;
        bgX = 0;
        bgY = (canvasHeight - bgH) / 2;
      } else {
        bgH = canvasHeight;
        bgW = canvasHeight * aspect;
        bgX = (canvasWidth - bgW) / 2;
        bgY = 0;
      }
      
      document.getElementById('removeBgBtn').style.display = 'block';
      redrawCanvas();
    };
  };
  reader.readAsDataURL(file);
});

document.getElementById('removeBgBtn').addEventListener('click', () => {
  pushStateToUndo();
  bgLoaded = false;
  bgImage = new Image();
  document.getElementById('removeBgBtn').style.display = 'none';
  redrawCanvas();
});

// === ИЗМЕНЕНИЕ РАЗМЕРА ХОЛСТА ===
document.getElementById('resizeCanvasBtn').addEventListener('click', () => {
  const w = parseInt(document.getElementById('canvasWidth').value);
  const h = parseInt(document.getElementById('canvasHeight').value);
  if (w > 0 && h > 0) {
    pushStateToUndo();
    canvasWidth = w;
    canvasHeight = h;
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
    if (bgLoaded) {
      const aspect = bgImage.width / bgImage.height;
      const canvasAspect = canvasWidth / canvasHeight;
      
      if (aspect > canvasAspect) {
        bgW = canvasWidth;
        bgH = canvasWidth / aspect;
        bgX = 0;
        bgY = (canvasHeight - bgH) / 2;
      } else {
        bgH = canvasHeight;
        bgW = canvasHeight * aspect;
        bgX = (canvasWidth - bgW) / 2;
        bgY = 0;
      }
    }
    redrawCanvas();
  }
});

// === СОХРАНЕНИЕ И ЗАГРУЗКА ПРОЕКТА (В ФАЙЛЫ) ===
document.getElementById('saveProjectBtn').addEventListener('click', () => {
  const projectData = {
    version: '2.0',
    timestamp: new Date().toISOString(),
    canvas: {
      width: canvasWidth,
      height: canvasHeight
    },
    background: {
      loaded: bgLoaded,
      src: bgLoaded ? bgImage.src : null,
      x: bgX,
      y: bgY,
      width: bgW,
      height: bgH
    },
    blocks: blocks.map(block => {
      const blockData = { ...block };
      if (block.type === 'image') {
        blockData.imageSrc = block.img.src;
        delete blockData.img;
      }
      return blockData;
    }),
    settings: {
      showCenterLines: showCenterLines,
      showSafeZones: showSafeZones,
      safeZoneTop: safeZoneTop,
      safeZoneBottom: safeZoneBottom,
      zoom: scale
    }
  };
  
  const dataStr = JSON.stringify(projectData, null, 2);
  const date = new Date().toLocaleDateString('ru-RU').replace(/\./g, '-');
  const time = new Date().toLocaleTimeString('ru-RU').replace(/:/g, '-');
  const filename = `story-project_${date}_${time}.json`;
  
  // Определяем iOS
  const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
  
  if (isIOS) {
    // Для iOS показываем данные для копирования
    const modal = document.createElement('div');
    modal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.95);
      z-index: 10000;
      display: flex;
      flex-direction: column;
      padding: 20px;
    `;
    
    const header = document.createElement('div');
    header.style.cssText = `
      color: white;
      margin-bottom: 10px;
      text-align: center;
      font-size: 18px;
      font-weight: bold;
    `;
    header.textContent = 'Сохранение проекта';
    
    const instruction = document.createElement('div');
    instruction.style.cssText = `
      color: white;
      margin-bottom: 20px;
      text-align: center;
      font-size: 14px;
    `;
    instruction.innerHTML = 'Выделите весь текст и скопируйте его.<br>Сохраните в приложении "Заметки" или "Файлы"';
    
    const textarea = document.createElement('textarea');
    textarea.value = dataStr;
    textarea.readOnly = true;
    textarea.style.cssText = `
      width: 100%;
      height: 50vh;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 8px;
      font-family: monospace;
      font-size: 12px;
      background: white;
      color: black;
    `;
    
    const btnContainer = document.createElement('div');
    btnContainer.style.cssText = `
      display: flex;
      gap: 10px;
      margin-top: 20px;
    `;
    
    const selectBtn = document.createElement('button');
    selectBtn.textContent = 'Выделить всё';
    selectBtn.style.cssText = `
      flex: 1;
      padding: 12px;
      background: #34c759;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 16px;
    `;
    selectBtn.onclick = () => {
      textarea.select();
      textarea.setSelectionRange(0, 99999);
    };
    
    const closeBtn = document.createElement('button');
    closeBtn.textContent = 'Закрыть';
    closeBtn.style.cssText = `
      flex: 1;
      padding: 12px;
      background: #007aff;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 16px;
    `;
    closeBtn.onclick = () => document.body.removeChild(modal);
    
    btnContainer.appendChild(selectBtn);
    btnContainer.appendChild(closeBtn);
    
    modal.appendChild(header);
    modal.appendChild(instruction);
    modal.appendChild(textarea);
    modal.appendChild(btnContainer);
    document.body.appendChild(modal);
    
    // Автоматически выделяем текст
    setTimeout(() => {
      textarea.select();
      textarea.setSelectionRange(0, 99999);
    }, 100);
  } else {
    // Для других устройств - стандартное скачивание
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }
  
  const btn = document.getElementById('saveProjectBtn');
  const originalText = btn.textContent;
  btn.textContent = '✔ Сохранено!';
  btn.style.background = 'var(--success)';
  setTimeout(() => {
    btn.textContent = originalText;
    btn.style.background = '';
  }, 2000);
});

document.getElementById('loadProjectBtn').addEventListener('click', () => {
  document.getElementById('loadProjectInput').click();
});

document.getElementById('loadProjectInput').addEventListener('change', async e => {
  const file = e.target.files[0];
  if (!file) return;
  
  try {
    const text = await file.text();
    const projectData = JSON.parse(text);
    
    if (!projectData.version) {
      alert('Неверный формат файла проекта');
      return;
    }
    
    pushStateToUndo();
    restoreProject(projectData);
    
    const btn = document.getElementById('loadProjectBtn');
    const originalText = btn.textContent;
    btn.textContent = '✔ Загружено!';
    btn.style.background = 'var(--success)';
    setTimeout(() => {
      btn.textContent = originalText;
      btn.style.background = '';
    }, 2000);
    
  } catch (error) {
    console.error('Ошибка загрузки проекта:', error);
    alert('Ошибка при загрузке файла проекта');
  }
  
  e.target.value = '';
});

// Функция восстановления проекта (используется и для файлов, и для localStorage)
async function restoreProject(projectData) {
  // Восстановление размера холста
  canvasWidth = projectData.canvas.width;
  canvasHeight = projectData.canvas.height;
  canvas.width = canvasWidth;
  canvas.height = canvasHeight;
  document.getElementById('canvasWidth').value = canvasWidth;
  document.getElementById('canvasHeight').value = canvasHeight;
  
  // Восстановление фона
  if (projectData.background.loaded && projectData.background.src) {
    bgImage = new Image();
    bgImage.src = projectData.background.src;
    bgImage.onload = () => {
      bgLoaded = true;
      bgX = projectData.background.x;
      bgY = projectData.background.y;
      bgW = projectData.background.width;
      bgH = projectData.background.height;
      document.getElementById('removeBgBtn').style.display = 'block';
      redrawCanvas();
    };
  } else {
    bgLoaded = false;
    bgX = projectData.background.x;
    bgY = projectData.background.y;
    bgW = projectData.background.width;
    bgH = projectData.background.height;
    document.getElementById('removeBgBtn').style.display = 'none';
  }
  
  // Восстановление блоков
  blocks = [];
  topGradientBlock = null;
  bottomGradientBlock = null;
  
  const loadPromises = [];
  
  for (let blockData of projectData.blocks) {
    if (blockData.type === 'image') {
      const img = new Image();
      const loadPromise = new Promise((resolve) => {
        img.onload = () => {
          const block = { ...blockData, img: img };
          delete block.imageSrc;
          blocks.push(block);
          resolve();
        };
      });
      img.src = blockData.imageSrc;
      loadPromises.push(loadPromise);
    } else if (blockData.type === 'gradient') {
      blocks.push(blockData);
      if (blockData.gradientType === 'top') {
        topGradientBlock = blockData;
      } else if (blockData.gradientType === 'bottom') {
        bottomGradientBlock = blockData;
      }
    } else {
      blocks.push(blockData);
    }
  }
  
  await Promise.all(loadPromises);
  
  // Обновление UI градиентов
  if (topGradientBlock) {
    document.getElementById('topGradientControls').style.display = 'block';
    document.getElementById('addTopGradientBtn').style.display = 'none';
    document.getElementById('topGradientHeight').value = topGradientBlock.height;
    document.getElementById('topGradientHeightValue').textContent = topGradientBlock.height + 'px';
    document.getElementById('topGradientOpacity').value = topGradientBlock.opacity * 100;
    document.getElementById('topGradientOpacityValue').textContent = (topGradientBlock.opacity * 100) + '%';
  } else {
    document.getElementById('topGradientControls').style.display = 'none';
    document.getElementById('addTopGradientBtn').style.display = 'block';
  }
  
  if (bottomGradientBlock) {
    document.getElementById('bottomGradientControls').style.display = 'block';
    document.getElementById('addBottomGradientBtn').style.display = 'none';
    document.getElementById('bottomGradientHeight').value = bottomGradientBlock.height;
    document.getElementById('bottomGradientHeightValue').textContent = bottomGradientBlock.height + 'px';
    document.getElementById('bottomGradientOpacity').value = bottomGradientBlock.opacity * 100;
    document.getElementById('bottomGradientOpacityValue').textContent = (bottomGradientBlock.opacity * 100) + '%';
  } else {
    document.getElementById('bottomGradientControls').style.display = 'none';
    document.getElementById('addBottomGradientBtn').style.display = 'block';
  }
  
  // Восстановление настроек
  if (projectData.settings) {
    showCenterLines = projectData.settings.showCenterLines || false;
    showSafeZones = projectData.settings.showSafeZones || false;
    safeZoneTop = projectData.settings.safeZoneTop || 250;
    safeZoneBottom = projectData.settings.safeZoneBottom || 100;
    
    document.getElementById('showCenterLines').checked = showCenterLines;
    document.getElementById('showSafeZones').checked = showSafeZones;
    document.getElementById('safeZoneTop').value = safeZoneTop;
    document.getElementById('safeZoneTopValue').textContent = safeZoneTop + 'px';
    document.getElementById('safeZoneBottom').value = safeZoneBottom;
    document.getElementById('safeZoneBottomValue').textContent = safeZoneBottom + 'px';
    
    if (projectData.settings.zoom) {
      scale = projectData.settings.zoom;
      document.getElementById('zoomSlider').value = scale;
      updateZoom();
    }
  }
  
  // Обновление ID счетчика
  if (blocks.length > 0) {
    nextBlockId = Math.max(...blocks.map(b => b.id)) + 1;
  } else {
    nextBlockId = 1;
  }
  
  selectedBlockId = null;
  deactivateBlockSelection();
  refreshBlockList();
  redrawCanvas();
}

// === ЭКСПОРТ ИЗОБРАЖЕНИЯ ===
document.getElementById('downloadBtn').addEventListener('click', () => {
  const tempCanvas = document.createElement('canvas');
  const tempCtx = tempCanvas.getContext('2d');
  tempCanvas.width = canvasWidth;
  tempCanvas.height = canvasHeight;
  
  const savedCenterLines = showCenterLines;
  const savedSafeZones = showSafeZones;
  const savedCanvas = canvas;
  const savedCtx = ctx;
  
  canvas = tempCanvas;
  ctx = tempCtx;
  
  showCenterLines = false;
  showSafeZones = false;
  redrawCanvas(true);
  
  // Определяем, iOS ли это
  const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
  
  if (isIOS) {
    // Для iOS показываем изображение в новом окне
    tempCanvas.toBlob((blob) => {
      const url = URL.createObjectURL(blob);
      
      // Создаем модальное окно
      const modal = document.createElement('div');
      modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.95);
        z-index: 10000;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 20px;
        overflow-y: auto;
      `;
      
      const instruction = document.createElement('div');
      instruction.style.cssText = `
        color: white;
        margin: 20px;
        text-align: center;
        font-size: 16px;
      `;
      instruction.innerHTML = 'Нажмите и удерживайте изображение,<br>затем выберите "Сохранить изображение"';
      
      const img = document.createElement('img');
      img.src = url;
      img.style.cssText = `
        max-width: 90%;
        max-height: 60vh;
        border: 2px solid white;
        border-radius: 8px;
        margin: 20px;
      `;
      
      const closeBtn = document.createElement('button');
      closeBtn.textContent = 'Закрыть';
      closeBtn.style.cssText = `
        padding: 12px 24px;
        background: #007aff;
        color: white;
        border: none;
        border-radius: 8px;
        font-size: 16px;
        margin-top: auto;
      `;
      closeBtn.onclick = () => {
        document.body.removeChild(modal);
        URL.revokeObjectURL(url);
      };
      
      modal.appendChild(instruction);
      modal.appendChild(img);
      modal.appendChild(closeBtn);
      document.body.appendChild(modal);
    });
  } else {
    // Для других устройств - стандартное скачивание
    const link = document.createElement('a');
    link.download = 'story.png';
    link.href = tempCanvas.toDataURL('image/png');
    link.click();
  }
  
  canvas = savedCanvas;
  ctx = savedCtx;
  showCenterLines = savedCenterLines;
  showSafeZones = savedSafeZones;
  redrawCanvas();
});

document.getElementById('copyBtn').addEventListener('click', async () => {
  try {
    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d');
    tempCanvas.width = canvasWidth;
    tempCanvas.height = canvasHeight;
    
    const savedCenterLines = showCenterLines;
    const savedSafeZones = showSafeZones;
    const savedCanvas = canvas;
    const savedCtx = ctx;
    
    canvas = tempCanvas;
    ctx = tempCtx;
    
    showCenterLines = false;
    showSafeZones = false;
    redrawCanvas(true);
    
    // Проверка поддержки Clipboard API
    if (navigator.clipboard && window.ClipboardItem) {
      tempCanvas.toBlob(async (blob) => {
        try {
          const item = new ClipboardItem({ 'image/png': blob });
          await navigator.clipboard.write([item]);
          showCopySuccess();
        } catch(e) {
          // Fallback для iOS
          fallbackCopyToClipboard(tempCanvas);
        }
      });
    } else {
      // Fallback для старых браузеров и iOS Safari
      fallbackCopyToClipboard(tempCanvas);
    }
    
    canvas = savedCanvas;
    ctx = savedCtx;
    showCenterLines = savedCenterLines;
    showSafeZones = savedSafeZones;
    redrawCanvas();
  } catch(err) {
    console.error('Ошибка копирования:', err);
    alert('На iOS копирование работает через долгое нажатие на изображение после его создания');
    // Показываем изображение для ручного копирования
    showImageForManualCopy();
  }
});
                                                        
function showCopySuccess() {
  const btn = document.getElementById('copyBtn');
  const originalText = btn.textContent;
  btn.textContent = '✔ Скопировано!';
  btn.style.background = 'var(--success)';
  setTimeout(() => {
    btn.textContent = originalText;
    btn.style.background = '';
  }, 2000);
}

function fallbackCopyToClipboard(canvas) {
  // Создаем модальное окно с изображением для iOS
  const modal = document.createElement('div');
  modal.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.9);
    z-index: 10000;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 20px;
  `;
  
  const instruction = document.createElement('div');
  instruction.style.cssText = `
    color: white;
    margin-bottom: 20px;
    text-align: center;
    font-size: 16px;
  `;
  instruction.innerHTML = 'Нажмите и удерживайте изображение,<br>затем выберите "Скопировать"';
  
  const img = document.createElement('img');
  img.src = canvas.toDataURL('image/png');
  img.style.cssText = `
    max-width: 90%;
    max-height: 70vh;
    border: 2px solid white;
    border-radius: 8px;
  `;
  
  const closeBtn = document.createElement('button');
  closeBtn.textContent = 'Закрыть';
  closeBtn.style.cssText = `
    margin-top: 20px;
    padding: 12px 24px;
    background: #007aff;
    color: white;
    border: none;
    border-radius: 8px;
    font-size: 16px;
  `;
  closeBtn.onclick = () => document.body.removeChild(modal);
  
  modal.appendChild(instruction);
  modal.appendChild(img);
  modal.appendChild(closeBtn);
  document.body.appendChild(modal);
}

function showImageForManualCopy() {
  const tempCanvas = document.createElement('canvas');
  const tempCtx = tempCanvas.getContext('2d');
  tempCanvas.width = canvasWidth;
  tempCanvas.height = canvasHeight;
  
  const savedCenterLines = showCenterLines;
  const savedSafeZones = showSafeZones;
  const savedCanvas = canvas;
  const savedCtx = ctx;
  
  canvas = tempCanvas;
  ctx = tempCtx;
  
  showCenterLines = false;
  showSafeZones = false;
  redrawCanvas(true);
  
  fallbackCopyToClipboard(tempCanvas);
  
  canvas = savedCanvas;
  ctx = savedCtx;
  showCenterLines = savedCenterLines;
  showSafeZones = savedSafeZones;
  redrawCanvas();
}

// === ГОРЯЧИЕ КЛАВИШИ ===
document.addEventListener('keydown', e => {
  if (e.ctrlKey && e.key === 'z') {
    e.preventDefault();
    undo();
  }
  if (e.ctrlKey && e.key === 'y') {
    e.preventDefault();
    redo();
  }
  if (e.ctrlKey && e.key === 'd' && selectedBlockId) {
    e.preventDefault();
    duplicateBlock();
  }
  if (e.key === 'Delete' && selectedBlockId) {
    e.preventDefault();
    document.getElementById('deleteBlockBtn').click();
  }
});

// === ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ===
function rgbaToHex(rgba) {
  if (rgba.startsWith('#')) return rgba;
  const parts = rgba.replace(/rgba?|\(|\)|\s/g, '').split(',');
  let r = parseInt(parts[0]), g = parseInt(parts[1]), b = parseInt(parts[2]);
  return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
}

function hexToRgba(hex, alpha = 1) {
  hex = hex.replace('#', '');
  if (hex.length === 3) {
    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
  }
  const bigint = parseInt(hex, 16);
  const r = (bigint >> 16) & 255;
  const g = (bigint >> 8) & 255;
  const b = bigint & 255;
  return `rgba(${r},${g},${b},${alpha})`;
}

// === ФУНКЦИЯ ОБНОВЛЕНИЯ МАСШТАБА ===
function updateZoom() {
  scale = parseFloat(document.getElementById('zoomSlider').value);
  canvasWrapper.style.transform = `scale(${scale})`;
  document.getElementById('zoomValue').textContent = Math.round(scale * 100) + '%';
}

// === ДОПОЛНИТЕЛЬНЫЕ ОБРАБОТЧИКИ МАСШТАБА ===
document.getElementById('zoomSlider').addEventListener('input', updateZoom);
document.getElementById('zoomIn').addEventListener('click', () => {
  scale = Math.min(3, scale + 0.1);
  document.getElementById('zoomSlider').value = scale;
  updateZoom();
});
document.getElementById('zoomOut').addEventListener('click', () => {
  scale = Math.max(0.1, scale - 0.1);
  document.getElementById('zoomSlider').value = scale;
  updateZoom();
});
document.getElementById('zoomReset').addEventListener('click', () => {
  scale = 1;
  document.getElementById('zoomSlider').value = scale;
  updateZoom();
});

  // === ИНИЦИАЛИЗАЦИЯ ПРИ ЗАГРУЗКЕ ===
  window.addEventListener('load', () => {
    // Загружаем автосохранение
    if (loadFromLocalStorage()) {
      console.log('Проект восстановлен из автосохранения');
    }
    
    // Запускаем автосохранение
    startAutosave();
    
    // Инициализация UI
    updateZoom();
    redrawCanvas();
    refreshBlockList();
    deactivateBlockSelection();
    updateUndoRedoButtons();
  });

  // Сохранение при закрытии
  window.addEventListener('beforeunload', () => {
    saveToLocalStorage();
  });

  // Обработка изменения видимости страницы (для мобильных)
  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      saveToLocalStorage();
    }
  });

  // === СВОРАЧИВАНИЕ БОКОВОЙ ПАНЕЛИ НА МОБИЛЬНЫХ ===
const toggleBtn = document.getElementById('toggleSidebar');
const sidebar = document.getElementById('sidebar');
let sidebarCollapsed = false;

// Показываем кнопку только на мобильных
if (window.innerWidth <= 768) {
  toggleBtn.style.display = 'block';
}

toggleBtn.addEventListener('click', () => {
  sidebarCollapsed = !sidebarCollapsed;
  if (sidebarCollapsed) {
    sidebar.style.maxHeight = '60px';
    sidebar.style.overflow = 'hidden';
    toggleBtn.textContent = '▼';
  } else {
    sidebar.style.maxHeight = '60vh';
    sidebar.style.overflow = 'auto';
    toggleBtn.textContent = '☰';
  }
});

// Обновляем видимость кнопки при изменении размера окна
window.addEventListener('resize', () => {
  if (window.innerWidth <= 768) {
    toggleBtn.style.display = 'block';
  } else {
    toggleBtn.style.display = 'none';
    sidebar.style.maxHeight = '';
    sidebar.style.overflow = '';
  }
});
  
</script>

</body>

</html>








